[[ch02_bitcoin_overview]]
== 比特幣如何運作

與傳統銀行和支付系統不同，比特幣系統不需要信任第三方。在比特幣中，每個用戶都可以使用在自己電腦上運行的軟體來驗證比特幣系統的每個方面是否正確運作。

在本章中，我們將通過追蹤比特幣系統中的單筆交易，並觀察它如何被記錄在區塊鏈（所有交易的分散式日誌）中，從高層次檢視比特幣。後續章節將深入探討交易、網路和挖礦背後的技術。

=== 比特幣概述

++++
<p class="fix_tracking">
比特幣系統由擁有包含密鑰的錢包的用戶、在網路上傳播的交易，以及通過競爭性運算產生共識區塊鏈（所有交易的權威日誌）的礦工組成。
</p>

<p class="fix_tracking2">
本章中的每個範例都基於比特幣網路上的實際交易，通過從一個錢包向另一個錢包發送資金來模擬多個用戶之間的互動。在追蹤交易通過比特幣網路到區塊鏈的過程中，我們將使用_區塊鏈瀏覽器_網站來視覺化每個步驟。區塊鏈瀏覽器是一個作為比特幣搜尋引擎運作的網頁應用程式，它允許你搜尋地址、交易和區塊，並查看它們之間的關係和流向。
</p>
++++

受歡迎的區塊鏈瀏覽器包括：

* https://blockstream.info[Blockstream Explorer]
* https://mempool.space[Mempool.Space]
* https://live.blockcypher.com[BlockCypher Explorer]

每個瀏覽器都有一個搜尋功能，可以接受比特幣地址、交易哈希值、區塊號碼或區塊哈希值，並從比特幣網路中檢索相應的資訊。對於每個交易或區塊範例，我們將提供一個URL，讓你可以自己查看並詳細研究它。

[[block-explorer-privacy]]
.區塊鏈瀏覽器隱私警告
[WARNING]
====
在區塊鏈瀏覽器上搜尋資訊可能會向運營商披露你對該資訊感興趣，使他們能夠將其與你的IP地址、瀏覽器詳情、過去的搜尋或其他可識別資訊關聯起來。如果你查看本書中的交易，區塊鏈瀏覽器的運營商可能會猜測你正在學習比特幣，這應該不是問題。但如果你查看自己的交易，運營商可能能夠猜測你收到了多少比特幣、花費了多少，以及目前擁有多少。
====

[[spending_bitcoin]]
=== 從線上商店購買

在上一章介紹的Alice是一位剛獲得第一批比特幣的新用戶。在<<getting_first_bitcoin>>中，Alice與她的朋友Joe見面，用現金換取了一些比特幣。從那時起，Alice購買了更多比特幣。現在Alice將進行她的第一筆支出交易，從Bob的線上商店購買一個高級播客節目的存取權。

Bob的網上商店最近開始接受比特幣支付，在其網站上添加了比特幣選項。Bob商店的價格以當地貨幣（美元）列出，但在結帳時，客戶可以選擇用美元或比特幣支付。

Alice找到她想買的播客節目並進入結帳頁面。在結帳時，除了通常的選項外，Alice還被提供使用比特幣支付的選項。購物車顯示美元價格，同時也顯示比特幣（BTC）價格，使用比特幣的現行匯率。

Bob的電子商務系統會自動創建一個包含_發票_的QR碼（<<invoice-QR>>）。

[[invoice-QR]]
.發票QR碼。
image::images/mbc3_0201.png["payment-request"]

與僅僅包含目標比特幣地址的QR碼不同，這個發票是一個QR編碼的URI，包含目標地址、支付金額和描述。這允許比特幣錢包應用程式預填發送支付所需的資訊，同時向用戶顯示人類可讀的描述。你可以用比特幣錢包應用程式掃描QR碼來看看Alice會看到什麼：

[[invoice-URI]]
.發票QR碼編碼了以下URI，定義在BIP21中：
----
bitcoin:bc1qk2g6u8p4qm2s2lh3gts5cpt2mrv5skcuu7u3e4?amount=0.01577764&
label=Bob%27s%20Store&
message=Purchase%20at%20Bob%27s%20Store

URI的組成部分

比特幣地址："bc1qk2g6u8p4qm2s2lh3gts5cpt2mrv5skcuu7u3e4"
支付金額："0.01577764"
接收地址的標籤："Bob's Store"
支付的描述："Purchase at Bob's Store"
----

[TIP]
====
試著用你的錢包掃描這個QR碼來查看地址和金額，但_不要_發送資金。
====

Alice使用她的智慧型手機掃描顯示的條碼。她的智慧型手機顯示向+Bob's Store+支付正確金額的資訊，她選擇發送來授權支付。在幾秒鐘內（大約與信用卡授權相同的時間），Bob在收銀機上看到交易。

[NOTE]
====
比特幣網路可以進行小數點交易，例如從毫比特幣（比特幣的千分之一）到比特幣的億分之一，這被稱為聰（satoshi）。本書在談論大於一個比特幣的金額和使用小數表示法時，使用與美元和其他傳統貨幣相同的複數規則，例如"10比特幣"或"0.001比特幣"。相同的規則也適用於其他比特幣記帳單位，如毫比特幣和聰。
====

你可以使用區塊鏈瀏覽器來檢查區塊鏈數據，例如Alice向Bob的https://oreil.ly/hAeyh[交易]。

在以下各節中，我們將更詳細地檢視這筆交易。我們將看到Alice的錢包如何構建它、它如何在網路上傳播、如何被驗證，以及最後Bob如何在後續交易中花費這筆金額。

=== 比特幣交易

簡單來說，交易告訴網路某些比特幣的所有者已授權將該價值轉移給另一個所有者。新所有者現在可以通過創建另一個交易來花費比特幣，該交易授權轉移給另一個所有者，以此類推，形成所有權鏈。

==== 交易輸入和輸出

交易就像複式記帳分類帳中的條目。每筆交易包含一個或多個_輸入_，用於花費資金。在交易的另一側，有一個或多個_輸出_，用於接收資金。輸入和輸出的總和不一定相同。相反，輸出的總和略小於輸入的總和，差額代表隱含的_交易費用_，這是由將交易包含在區塊鏈中的礦工收取的小額費用。比特幣交易在<<transaction-double-entry>>中顯示為記帳分類帳條目。

交易還包含每個被花費的比特幣金額（輸入）的所有權證明，以所有者的數位簽名形式，任何人都可以獨立驗證。在比特幣術語中，花費就是簽署一筆交易，將價值從之前的交易轉移給由比特幣地址識別的新所有者。

[[transaction-double-entry]]
.交易作為複式記帳。
image::images/mbc3_0202.png["Transaction Double-Entry"]

==== 交易鏈

Alice向Bob商店的支付使用之前交易的輸出作為其輸入。在上一章中，Alice從她的朋友Joe那裡收到了比特幣，以換取現金。我們在<<transaction-chain>>中將其標記為_交易1_（Tx1）。

Tx1向被Alice的密鑰鎖定的輸出發送了0.001比特幣（100,000聰）。她向Bob商店的新交易（Tx2）引用了之前的輸出作為輸入。在圖示中，我們使用箭頭並將輸入標記為"Tx1:0"來顯示該引用。在實際交易中，引用是Alice從Joe那裡收到資金的交易的32位元組交易識別碼（txid）。":0"表示Alice收到資金的輸出位置；在這種情況下，是第一個位置（位置0）。

如圖所示，實際的比特幣交易並不明確包含其輸入的價值。要確定輸入的價值，軟體需要使用輸入的引用來找到被花費的之前交易輸出。

Alice的Tx2包含兩個新輸出，一個支付75,000聰用於播客，另一個支付20,000聰返回給Alice作為找零。

[[transaction-chain]]
.交易鏈，其中一個交易的輸出是下一個交易的輸入。
image::images/mbc3_0203.png["Transaction chain"]

[TIP]
====
序列化的比特幣交易--軟體用於發送交易的數據格式--使用最小定義的鏈上價值單位的整數來編碼要轉移的價值。當比特幣首次創建時，這個單位沒有名稱，一些開發者簡單地稱它為_基本單位_。後來許多用戶開始稱這個單位為_聰_（sat），以紀念比特幣的創建者。在<<transaction-chain>>和本書的其他一些圖示中，我們使用聰值，因為這是協議本身使用的單位。
====

==== 找零

除了向比特幣接收者支付的一個或多個輸出外，許多交易還會包含一個向比特幣花費者支付的輸出，稱為_找零_輸出。這是因為交易輸入，就像紙幣一樣，不能被部分花費。如果你在商店購買5美元的商品，但使用20美元的鈔票支付，你會期望收到15美元的找零。相同的概念適用於比特幣交易輸入。如果你購買價值5比特幣的商品，但只有一個價值20比特幣的輸入可以使用，你會向商店所有者發送一個5比特幣的輸出，並向自己發送一個15比特幣的輸出作為找零（不計算你的交易費用）。

在比特幣協議層面，找零輸出（及其支付的地址，稱為_找零地址_）和支付輸出沒有區別。

重要的是，找零地址不必與輸入的地址相同，為了隱私原因，通常是所有者錢包中的新地址。在理想情況下，輸出的兩種不同用途都使用從未見過的地址，並且在其他方面看起來相同，防止任何第三方確定哪些輸出是找零，哪些是支付。然而，為了說明目的，我們在<<transaction-chain>>中為找零輸出添加了陰影。

並非每筆交易都有找零輸出。那些沒有找零輸出的交易被稱為_無找零交易_，它們只能有一個輸出。無找零交易只有在花費金額大致等於交易輸入中的可用金額減去預期的交易費用時才是一個實用的選項。在<<transaction-chain>>中，我們看到Bob創建Tx3作為一筆無找零交易，花費他在Tx2中收到的輸出。

==== 幣種選擇

不同的錢包在選擇支付中使用的輸入時使用不同的策略，稱為_幣種選擇_。

它們可能會聚合許多小額輸入，或使用一個等於或大於所需支付的輸入。除非錢包能夠以某種方式聚合輸入以完全匹配所需支付加上交易費用，否則錢包將需要生成一些找零。這與人們處理現金的方式非常相似。如果你總是使用口袋裡最大的鈔票，你最終會得到滿口袋的零錢。如果你只使用零錢，你通常只會有大鈔。人們下意識地在這兩個極端之間找到平衡，比特幣錢包開發者努力編程實現這種平衡。

==== 常見交易形式

最常見的交易形式是簡單支付。這種類型的交易有一個輸入和兩個輸出，如<<transaction-common>>所示。

[[transaction-common]]
.最常見的交易。
image::images/mbc3_0204.png["Common Transaction"]

另一種常見的交易形式是_整合交易_，它將多個輸入花費到單個輸出中（<<transaction-consolidating>>）。這代表現實世界中將一堆硬幣和紙幣兌換成單張較大面額紙幣的等效行為。錢包和企業有時會生成這類交易來清理許多小額資金。

[[transaction-consolidating]]
.整合交易聚合資金。
image::images/mbc3_0205.png["Aggregating Transaction"]

最後，在區塊鏈上經常看到的另一種交易形式是_批量支付_，它向代表多個接收者的多個輸出支付（<<transaction-distributing>>）。這種類型的交易有時被商業實體用於分配資金，例如向多個員工處理工資支付。

[[transaction-distributing]]
.批量交易分配資金。
image::images/mbc3_0206.png["Distributing Transaction"]

=== 構建交易

Alice的錢包應用程式包含選擇輸入和生成輸出以根據Alice的規格構建交易的所有邏輯。Alice只需要選擇目的地、金額和交易費用，其餘的都在錢包應用程式中進行，她看不到細節。重要的是，如果錢包已經知道它控制哪些輸入，它可以在完全離線的情況下構建交易。就像在家寫支票，然後稍後通過信封寄給銀行一樣，交易不需要在連接到比特幣網路時構建和簽署。

==== 獲取正確的輸入

Alice的錢包應用程式首先必須找到可以支付她想發送給Bob的金額的輸入。大多數錢包都會追蹤屬於錢包中地址的所有可用輸出。因此，Alice的錢包會包含來自Joe交易的交易輸出副本，該交易是用現金創建的（見<<getting_first_bitcoin>>）。在完整節點上運行的比特幣錢包應用程式實際上包含每個已確認交易的未使用輸出副本，稱為_未使用交易輸出_（UTXOs）。然而，因為完整節點使用更多資源，許多用戶錢包運行輕量級客戶端，只追蹤用戶自己的UTXOs。

在這種情況下，這個單個UTXO足以支付播客的費用。如果不是這種情況，Alice的錢包應用程式可能必須組合幾個較小的UTXO，就像從錢包中挑選硬幣一樣，直到找到足夠的錢來支付播客。在這兩種情況下，都可能需要一些找零，我們將在下一節中看到，當錢包應用程式創建交易輸出（支付）時。

==== 創建輸出

交易輸出是通過腳本創建的，腳本說的是類似這樣的話："這個輸出支付給能夠提供與Bob的公開地址對應的密鑰簽名的人。"因為只有Bob擁有與該地址對應的密鑰的錢包，只有Bob的錢包能夠提供這樣的簽名來稍後花費這個輸出。因此，Alice將用對Bob簽名的要求來_限制_輸出價值。

這筆交易還將包含第二個輸出，因為Alice的資金包含比播客成本更多的錢。Alice的找零輸出是在向Bob支付的同一筆交易中創建的。本質上，Alice的錢包將她的資金分成兩個輸出：一個給Bob，一個返回給她自己。她然後可以在後續交易中花費找零輸出。

最後，為了讓交易能夠及時被網路處理，Alice的錢包應用程式將添加一筆小額費用。費用沒有在交易中明確說明；它是由輸入和輸出之間的價值差額隱含的。這筆交易費用由礦工作為將交易包含在記錄在區塊鏈上的區塊中的費用收取。

[[transaction-alice-url]]
[TIP]
====
查看https://oreil.ly/GwBq1[Alice向Bob商店的交易]。
====

==== 將交易添加到區塊鏈

由Alice的錢包應用程式創建的交易包含確認資金所有權和分配新所有者所需的一切。現在，交易必須傳輸到比特幣網路，在那裡它將成為區塊鏈的一部分。在下一節中，我們將看到交易如何成為新區塊的一部分，以及區塊如何被挖出。最後，我們將看到新區塊一旦添加到區塊鏈中，隨著更多區塊的添加，網路對它的信任度越來越高。

===== 傳輸交易

因為交易包含處理它所需的所有資訊，所以它如何或在哪裡傳輸到比特幣網路並不重要。比特幣網路是一個點對點網路，每個比特幣節點通過連接到其他幾個比特幣節點來參與。比特幣網路的目的是向所有參與者傳播交易和區塊。

===== 如何傳播

比特幣點對點網路中的節點是具有軟體邏輯和數據的程式，這些邏輯和數據使它們能夠完全驗證新交易的正確性。節點之間的連接通常被視覺化為圖中的邊（線），節點本身是節點（點）。因此，比特幣節點通常被稱為"完整驗證節點"，簡稱_完整節點_。

Alice的錢包應用程式可以通過任何類型的連接向任何比特幣節點發送新交易：有線、WiFi、行動網路等。它也可以將交易發送給另一個程式（如區塊鏈瀏覽器），該程式將轉發給節點。她的比特幣錢包不必直接連接到Bob的比特幣錢包，也不必使用Bob提供的網際網路連接，儘管這兩種選擇也是可能的。任何收到它之前未見過的有效交易的比特幣節點都會將它轉發給它所連接的所有其他節點，這種傳播技術被稱為_八卦_。因此，交易迅速在點對點網路中傳播，在幾秒鐘內到達大部分節點。

===== Bob的視角

如果Bob的比特幣錢包應用程式直接連接到Alice的錢包應用程式，Bob的錢包應用程式可能是第一個收到交易的。然而，即使Alice的錢包通過其他節點發送交易，它也會在幾秒鐘內到達Bob的錢包。Bob的錢包會立即將Alice的交易識別為入帳支付，因為它包含一個可由Bob的密鑰兌現的輸出。Bob的錢包應用程式也可以獨立驗證交易格式良好。如果Bob使用他自己的完整節點，他的錢包可以進一步驗證Alice的交易只花費有效的UTXOs。

=== 比特幣挖礦

Alice的交易現在在比特幣網路上傳播。它不會成為_區塊鏈_的一部分，直到它通過一個稱為_挖礦_的過程被包含在一個區塊中，並且該區塊已被完整節點驗證。見<<mining>>獲取詳細說明。

比特幣的防偽系統基於運算。交易被((("transactions", "in blocks", secondary-sortas="blocks")))((("blocks")))打包成_區塊_。區塊有一個非常小的標頭，必須以非常特定的方式形成，需要大量的運算才能正確--但只需要少量的運算就能驗證其正確性。挖礦過程在比特幣中有兩個目的：

[role="less_space pagebreak-before"]
* 礦工只能通過創建遵循所有比特幣_共識規則_的區塊來獲得誠實的收入。因此，礦工通常被激勵只在他們的區塊和他們建立的區塊中包含有效交易。這允許用戶選擇性地做出基於信任的假設，即區塊中的任何交易都是有效交易。

* 挖礦目前每個區塊創建新的比特幣，幾乎像中央銀行印製新錢一樣。每個區塊創建的比特幣數量是有限的，並隨著時間推移而減少，遵循固定的發行時間表。

挖礦在成本和獎勵之間達到了微妙的平衡。挖礦使用電力來解決運算問題。成功的礦工將以新比特幣和交易費用的形式收取_獎勵_。然而，只有在礦工只包含有效交易的情況下才能收取獎勵，比特幣協議的_共識_規則決定什麼是有效的。這種微妙的平衡為比特幣提供了安全性，而不需要中央權威。

挖礦被設計為一個去中心化的抽獎。每個礦工可以通過創建一個_候選區塊_來創建自己的抽獎券，該區塊包含他們想要挖礦的新交易加上一些額外的數據欄位。礦工將他們的候選區塊輸入到一個特別設計的演算法中，該演算法((("hash functions")))擾亂（或"哈希"）數據，產生看起來與輸入數據完全不同的輸出。這個_哈希_函數對於相同的輸入總是產生相同的輸出--但沒有人能預測新輸入的輸出會是什麼樣子，即使它與之前的輸入只有細微的差別。如果哈希函數的輸出匹配由比特幣協議確定的模板，礦工就贏得了抽獎，比特幣用戶將接受包含其交易的區塊作為有效區塊。如果輸出不匹配模板，礦工對他們的候選區塊做一個小改變並再次嘗試。截至本文撰寫時，礦工在找到獲勝組合之前需要嘗試的候選區塊數量約為1680億兆。這也是哈希函數需要運行的次數。

然而，一旦找到獲勝組合，任何人都可以通過只運行一次哈希函數來驗證區塊是有效的。這使得有效區塊成為需要難以置信的工作量來創建但只需要微不足道的工作量來驗證的東西。簡單的驗證過程能夠概率性地證明工作已經完成，所以生成該證明所需的數據--在這種情況下是區塊--被稱為((("proof-of-work algorithm"))) _工作量證明（PoW）_。

交易被添加到新區塊中，優先考慮費率最高的交易，還有一些其他標準。每個礦工在從網路收到前一個區塊後立即開始挖礦新候選交易區塊的過程，知道其他礦工贏得了那一次抽獎。他們立即創建一個新的候選區塊，承諾前一個區塊，用交易填充它，並開始計算候選區塊的PoW。每個礦工在他們的候選區塊中包含一個特殊交易，該交易向他們自己的比特幣地址支付區塊獎勵加上候選區塊中包含的所有交易的交易費用總和。如果他們找到一個使候選區塊成為有效區塊的解決方案，在他們的成功區塊被添加到全球區塊鏈後，他們將收到這個獎勵，他們包含的獎勵交易變得可花費。參與礦池的礦工已經設置他們的軟體來創建將獎勵分配給礦池地址的候選區塊。從那裡，獎勵的一部分按他們貢獻的工作量比例分配給礦池礦工。

Alice的交易被網路接收並包含在未驗證交易池中。一旦被完整節點驗證，它就被包含在一個候選區塊中。在Alice的錢包首次傳輸交易大約五分鐘後，一個礦工找到了區塊的解決方案並向網路宣布。在每個其他礦工驗證獲勝區塊後，他們開始新的抽獎來生成下一個區塊。

包含Alice交易的獲勝區塊成為了區塊鏈的一部分。包含Alice交易的區塊被計為該交易的((("confirmations")))((("clearing transactions")))((("transactions", "clearing")))一個_確認_。在包含Alice交易的區塊通過網路傳播後，創建一個包含Alice交易不同版本的替代區塊（例如不向Bob支付的交易）將需要執行與所有比特幣礦工創建全新區塊相同的工作量。當有多個替代區塊可供選擇時，比特幣完整節點選擇具有最多總PoW的有效區塊鏈，稱為_最佳區塊鏈_。為了讓整個網路接受替代區塊，需要在替代區塊之上挖出一個額外的新區塊。

這意味著礦工有選擇。他們可以與Alice合作創建一個替代交易，其中她向Bob支付，也許Alice向礦工支付她之前支付給Bob的部分資金。這種不誠實的行為將需要他們花費創建兩個新區塊所需的工作量。相反，誠實行事的礦工可以創建一個新區塊，並從他們包含在其中的所有交易中收取費用，加上區塊補貼。通常，不誠實地創建兩個區塊以獲得少量額外支付的高成本遠不如誠實地創建新區塊有利可圖，這使得已確認的交易不太可能被故意更改。對Bob來說，這意味著他可以開始相信Alice的支付可以信賴。

[TIP]
====
你可以看到包含https://oreil.ly/7v_lH[Alice交易]的區塊。
====

在包含Alice交易的區塊廣播大約19分鐘後，另一個礦工挖出了一個新區塊。因為這個新區塊建立在包含Alice交易的區塊之上（給Alice的交易兩個確認），Alice的交易現在只能通過挖出兩個替代區塊--加上建立在它們之上的新區塊--來更改，總共需要挖出三個區塊才能讓Alice收回她發送給Bob的錢。建立在包含Alice交易的區塊之上的每個區塊都計為一個額外的確認。隨著區塊堆疊在彼此之上，逆轉交易變得越來越困難，從而給Bob越來越多的信心，相信Alice的支付是安全的。

在<<block-alice1>>中，我們可以看到包含Alice交易的區塊。在它下面有數十萬個區塊，通過區塊鏈（blockchain）相互連結，一直追溯到區塊#0，被稱為((("genesis block"))) _創世區塊_。隨著時間推移，隨著新區塊的"高度"增加，整個鏈的運算難度也隨之增加。按照慣例，任何具有超過六個確認的區塊都被認為很難更改，因為重新計算六個區塊（加上一個新區塊）需要巨大的運算量。我們將在<<mining>>中更詳細地檢視挖礦過程和它建立信任的方式。

[[block-alice1]]
.包含Alice交易的區塊。
image::images/mbc3_0207.png["Alice's transaction included in a block"]

[role="less_space pagebreak-before"]
=== 花費交易

現在((("transactions", "spending bitcoins", id="transaction-spend2")))((("bitcoins", "spending", id="bitcoin-spend2")))((("spending bitcoins", id="spend-bitcoin2")))Alice的交易已經作為區塊的一部分嵌入到區塊鏈中，它對所有比特幣應用程式都是可見的。每個比特幣完整節點都可以獨立驗證交易是有效且可花費的。完整節點驗證從比特幣首次在區塊中生成到每個後續交易直到到達Bob地址的每筆資金轉移。輕量級客戶端可以通過確認交易在區塊鏈中且有幾個區塊在其之後被挖出來部分驗證支付，從而提供礦工為其投入大量工作的保證（見<<spv_nodes>>）。

Bob現在可以花費這個和其他交易的輸出。例如，Bob可以通過將Alice的播客支付價值轉移給這些新所有者來支付承包商或供應商。當Bob花費從Alice和其他客戶那裡收到的支付時，他擴展了交易鏈。讓我們假設Bob向他的網頁設計師Gopesh支付新網頁的費用。現在交易鏈看起來像<<block-alice2>>。

[[block-alice2]]
.Alice的交易作為從Joe到Gopesh的交易鏈的一部分。
image::images/mbc3_0208.png["Alice's transaction as part of a transaction chain"]

在本章中，我們看到了交易如何建立一個將價值從所有者轉移到所有者的鏈。我們還追蹤了Alice的交易從在她的錢包中創建的那一刻，通過比特幣網路，到礦工將其記錄在區塊鏈上的過程。在本書的其餘部分，我們將檢視錢包、地址、簽名、交易、網路，最後是挖礦背後的具體技術。
